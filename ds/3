3.1、
一、
1、A -> B 
2、C
3、B
4、C
5、A
6、A
7、C
8、C
9、D
10、A
11、B
12、D
13、C -> D 
14、D
15、C
16、C
17、C
18、B -> D 
19、D
20、C
21、C
22、C
23、C
24、C
25、B
26、B
27、C
28、A
二、
1、
CDEBA
CDBEA
CDBAE
2、

BCAED 可以
DBACE 不可以

3、
（1）、ACD 合法
（2）、
bool Is_valid(char *str,int n){
	int count = 0;
	for(int i=0;i<n;i++){
		if(*(str+i)=='O'){
			count--;
		}else{
			count++;
		}
		if(count<0)
			return false;
	}
	if (count==0)
	{
		return true;
	}
	return false;
}
4、 
bool Is_centre(LinkList L,int n){
	int i;
	char s[n/2];
	p=L->next;
	for (i = 0; i < n/2; ++i){
		s[i]=p->data;
		p=p->next;
	}
	i--;
	if (n%2==1){
		p=p->next;
	}
	while(p!=NULL&&s[i]==p->data){
		p=p->next;
		i--;
	}
	if (i==-1){
		return 1;
	}else{
		return 0;
	}
}
5、 
#define maxsize 100		//设置共享存储空间的最大容量
#define element int 	//假设元素类型为int
typedef struct{
	element stack[maxsize];		//栈空间
	int top[2];					//栈顶的两个指针
}stk;
stk s;	//定义全局变量
int push(int i,element x){
	if (i<0||i>1){
		printf("栈号输入不对\n");
		exit(0);
	}
	if(s.top[1]-s.top[0]==1){
		printf("栈满\n");
		exit(0);
	}
	if (i==0){
		s.stack[++s.top[i]]=x;
	}else{
		s.stack[--s.top[i]]=x;
	}
	return 1;
}
element pop(int i){
	if (i<0||i>1){
		printf("栈号输入不对\n");
		exit(0);
	}
	switch(i){
		case 0:
			if(s.top[0]==-1){
				printf("栈空\n");
				return -1;
			}else{
				return s.stack[s.top[0]--];
			}
		case 1:
			if(s.top[1]==maxsize){
				printf("栈空\n");
				return -1;
			}else{
				return s.stack[s.top[1]++];
			}
	}
}
3.2
一、
1、D
2、B
3、D
4、B
5、C -> D
6、C
7、B
8、A -> B 
9、C
10、A
11、B
12、A
13、A
14、D
15、D
16、A
17、C
18、C
二、
1、
bool EnQueue(SqQueue &Q,ElemType x){
	if(Q.front==Q.rear && Q.tag==1)
		return false;//队满
	Q.data[Q.rear]=x;
	Q.rear=(Q.rear+1)%maxSize;
	Q.tag=1;
	return true;
}
bool DeQueue(SqQueue&Q,ElemType &x){
	if(Q.front==Q.rear && Q.tag==0)
		return false;//队空
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%maxSize;
	Q.tag=0;
	return true;
}
2、

将队列中的元素依次入栈，然后把栈中的元素出栈在入队，即完成元素的逆置。
int revert(SqQueue &Q,S){
	ElemType *x=(ElemType*)malloc(sizeof(ElemType));
	while(!QueueEmpty(Q)){
		DeQueue(&Q,x)
		Push(&S,*x);
	}
	while(!StackEmpty(S)){
		Pop(&S,*x);
		EnQueue(&Q,x);
	}
	return 1;
}
3、
EnQueue(s){
	while(!StackEmpty(S1)){
		Pop(S1,x);
		Push(S2,x);
	}
	Push(S1,s);
		while(!StackEmpty(S2)){
		Pop(S2,x);
		Push(S1,x);
	}
}
DeQueue(x){
	Pop(S1,x);
}
3.3
一、
1、D
2、B
3、D -> C
4、B
5、B
6、B
7、B
8、C
9、B
10、A
11、A
12、B
13、A
二、
1、
bool Isvalid(char *s){
	Stack *S=(Stack*)malloc(sizeof(Stack));
	char *x=(char*)malloc(sizeof(char));
	Initial(S);
	while(*!='\0'){
		switch(*s){
			case '(':
			case '[':
			case '{':
				Push(S,*s);
				break;
			case ')':
				Pop(S,x);
				if(*x!='(')
					return false;
			case ']':
				Pop(S,x);
				if(*x!='{')
					return false;
			case '}':
				Pop(S,x);
				if(*x!='{')
					return false;
			default:
				break;
		}
		s++;
	}
	if(!StackEmpty(S)){
		return false;
	}else{
		return true;
	}
}
2、

char* justify(char *s){
	Stack *S=(Stack*)malloc(sizeof(Stack));
	InitStack(S);
	char *re=(char*)malloc(sizeof(char)),*x=re;
	while(*s!='\0'){
		if(*s=='H'){
			Push(S,*s);
			s++;
		}else{
			*x=*s;
			s++;
			x++;
		}
	}
	while(!StackEmpty(S)){
		Pop(S,x)
		x++;
	}
	x=NULL;
	return re;
}

3、
double P(int n,double x){
	if(n==0){
		return 1;
	}else if(n==1){
		return 2*x;
	}else{
		return 2*x*P(n-1,x)-2*(n-1)*P(n-2,x);
	}
}

4、

Queue q;	//渡船队列
Queue q1;	//客车队列
Queue q2;	//火车队列

void manager(){
	int i=0,j=0;
	while(j<10){
		if(!QueueEmpty(q1)&&i<4){
			DeQueue(q1,x);
			EnQueue(q,x);
			i++;
			j++;
		}else if(!QueueEmpty(q2)&&i==4){
			DeQueue(q2,x);
			EnQueue(q,x);
			i=0;
			j++;
		}else{
			while(j<10&&i<4&&!QueueEmpty(q2)){ //客车队列为空
				DeQueue(q2,x);
				EnQueue(q,x);
				i++;
				j++;			
			}
		}
		if(QueueEmpty(q1)&&QueueEmpty(q2))
			j=11;
	}
}

3.4
一、
1、D
2、C
3、A
4、D
5、B
6、B 
7、C
8、B
9、B -> A 压缩

